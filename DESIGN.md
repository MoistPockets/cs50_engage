The Engage application comes in the form of an Express and Node.js backend alongside an Angular front-end. The back end ultimately consists of a series of routing and logic that provides information to the front end by a series of HTTP requests. 

Structure: my program's backend functions in a modular fashion in order to allow for the implimentation of varying features (scaling) more easily.
---------------
Models: 
The models consist of Mongoose Schemas upon which all data will conform to. My program utilizes a non-relational database in order to map out Users, Organizations, and Events within different Schemas. The relations between them are contingent upon a few reference values that allow for me to create relations between them and effectively manipulate the data. I found this to be much more effective than utilizing a relational database wherein I would have to be much more dilligent about my data from the very start and have to do increadibly complex joins to achieve the same levels of success with MongoDB. By using MongoDB, I was able to continiously add and remove things from my schema without drastically having to restructure my program. I decided rather than storing references in both the User and Organization schema, I could store the reference within the Organization and, in order to find user's joined groups, search the Organization schema for all users who's UserID's are within the member array before concatenating that onto the User JSON returned by the profile function. There exists three models: User, Controller, and Events. The events are mapped to the organizations through an array of event id's located in the Organization schema that are populated identically to the population of User organizations.

The UserSchema consists of three methods: createHash, compareHash, and createJWT createHash is reponsible for creating the user's hash. It takes in a text password and utilizes the bcrypt module to generate a salt that is applied to the hash function. This hash function is then used to hash the user's password which is ultimately returned. The compareHash function takes in a password (string of text) and compares it to the User's password. This is done utilizing bcrypts compareSynce function which compares a string with a generated hash. The last function, createJWT, returns a signed JWT (JWT consists of a header, payload, and a signature). Within its payload, is the user's id, email, and name. The JWT is then signed using our secret located within the config file (config/config.js), and set ot expire after two hours. 

Controllers: 
The controllers consits of functions that are called upon by the routes within the routes.js located in the config folder. All controllers are located in app/controllers. They mostly consist of basic request to the databse, error handling, and successful rendering of JSON information to the frontend. These functions are pretty much similar with the exception of the profile function within the user controller. All of the functions are contingent upon the module.exports feature, which makes available an exports object to whatever file requires a given file. By adding things to the exports object, they are accessible by other files. 

Rather than using sessions, I thought it best an dmost interesting to try a different form of keeping track of a user. Instead, I utilized JSON Web Tokens that were, in theory, supposed to be sent to the user upon registration and successful log in, and attached to each request by the front-end. This token is signed using my back-end's secret so that it may only be generated by me. 

Routes:
Wihtin the routes.js file exist the routing for my application's backend. Each route specifies a function to run with a given HTTP request. The authentication is removed from the application, but in order to add it back, simply follow the instructions at the top of the file which utilizes Expresses middleware functionallites. 

Below are the following routes and their corresponding actions. All API routes are prefixed by '/api/' and return JSON formatted data so that they may more easily be manipulated by the Javascript front end: 

Route: http://localhost:3000/api/register
POST: Registers a user, creating a new user

Route: http://localhost:3000/api/users
POST: Successfully logs a user in, and in theory, returns a JWT
GET: Returns all users within the database

Route: http://localhost:3000/api/users/:user_id
GET: Returns the user with the specified user id

Route: http://localhost:3000/api/profile
GET: Returns the profile of the user whose token authorizes the request

Route: http://localhost:3000/api/organizations

GET: Returns a list of all organizations within the database
POST: Creates a new organization 

Route: http://localhost:3000/api/organizations/:org_id

GET: Returns a singular, specific organization
POST: Adds the user to an organizations members array


Route: http://localhost:3000/api/events:org_id?
GET: Returns either all events or specific events for a group
POST: Creates a new event

Route: http://localhost:3000/api/events:event_id?
POST: Joins a new event

